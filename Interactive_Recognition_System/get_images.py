# -*- coding: utf-8 -*-
"""Get_Images.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F4cQRwkz-bpoxnxzBYCc4e8akuhRkeGY
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import PIL.ImageOps

# images = np.load("./SampleData.npy")

# 查找跳变点
def boundary(line):
    result = []
    Signal = line[0]
    for i, val in enumerate(line):
        if val != Signal:
           result.append(i)
           Signal = val

    return result

def get_images(images, inv=True):
    # To PIL image
    img = Image.fromarray(images)
    # 灰度
    img = img.convert("L")
    # 反转
    if inv:
    	img = PIL.ImageOps.invert(img)
    # To numpy array
    img = np.asarray(img)
    # 每列最大值
    line = np.max(img,axis=0)
    # plt.imshow(img)
    points = boundary(line)
    # print("Change Points:", points)
    
    # 裁切点
    CUT = [0]
    for i, item in enumerate(points):
        if i % 2 == 0 and i != 0:
            res = (points[i] + points[i-1])/2
            CUT.append(int(res))
    
    lastone = points[-1]
    if lastone == 0:
        CUT.append(points[-1] + 30)
    elif img.shape[1] - lastone > 160:
        lastone  = lastone + 30 
        CUT.append(lastone)
    else:
        CUT.append(img.shape[1])

    # print("Cut Points:", CUT)

    cut_images = []
    for i in range(len(CUT)-1):
        one_img = img[:, CUT[i]:CUT[i+1]]
        cut_images.append(one_img)

    return cut_images

# plt.imshow(get_images(images)[0])

